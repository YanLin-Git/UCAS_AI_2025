# 堆排序

# 一、堆的数据结构
- 逻辑结构: 完全二叉树
- 物理结构: 顺序存储

<details>
<summary>示意图</summary>

![max_heap](pngs/max_heap.png)
> 注意这里，数组A的下标是从`1`开始

</details>

# 二、堆排序使用到的几个函数
## 2.1 修复堆

<details>
<summary>图解</summary>

![max_heapify](pngs/max_heapify.png)

</details>

<details>
<summary>伪代码</summary>

![max_heapify_code](pngs/max_heapify_code.png)

</details>

<details>
<summary>复杂度分析</summary>

我们最多需要从根结点到某一个叶子结点。
- 假设初始位置在根结点
    - 递归一次，需要调整的位置来到第二层
    - 递归两次，需要调整的位置来到第三层
    - 递归h-1次（h为树的深度），需要调整的位置来到叶子结点，结束

又 $h=\lfloor \lg n \rfloor + 1$，因此最多需要递归 $\lfloor \lg n \rfloor$ 次  
每次递归，需要进行2次比较  
所以时间复杂度为 $O(\lg n)$

</details>

## 2.2 构建堆
有了前面的**堆修复算法**，可以很方便地来**构建堆**

<details>
<summary>伪代码</summary>

![build_max_heap](pngs/build_max_heap.png)

</details>

> 先将n个数字存入数组中，接下来调整位置就可以了，是一种**原地算法**  
> **分**：找到左、右子结点，先去构建左、右子树  
> **底**：到达叶结点时，什么都不需要做，已经建好了，直接返回即可  
> **合**：当左、右子树已经是`大顶堆`时，我们只需要调用上一节的**堆修复算法**，将根结点调整到合适位置即可

#### 复杂度分析
> 不妨设$n=2^{h+1}-1$，即**完美二叉树**

- 每次将规模为n的问题，划分为2个规模为n/2的问题
    - a=2, b=2
- 每次**合**的复杂度，即调用一次**堆修复算法**
    - $f(n) = O(\lg n)$
- 于是由**主方法**`规则1`：$T(n) = \Theta(n)$


## 2.3 堆排序

<details>
<summary>伪代码</summary>

![heap_sort](pngs/heap_sort.png)

</details>

> 这段代码很直观：
> 1. **构建堆**
> 2. 删掉堆顶元素(放在已排序的部分)，将堆末尾的元素置顶，堆规模减1，然后**修复堆**
>       - 很优雅地原地排序
> 3. 重复第2步，直到堆里只剩一个元素



# 三、堆的应用举例：优先队列
通过伪代码展示了优先队列的几个操作:
1. 提升某个结点的优先级
    - 一直往上找：若当前结点优先级>父结点优先级，就与父结点交换。
2. 插入新结点
    - 先在堆的末尾插入一个优先级为 $-\infty$ 的结点，再提升该结点的优先级
3. 取出优先级最大的结点
    - 即取出堆顶元素
    - 取出堆顶后，将堆末尾的元素置顶，堆规模减1，然后**修复堆**
4. 降低某个结点的优先级
    - PPT里没列举，直接**修复堆**即可